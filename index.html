<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>放り込みフォーメーション表</title>
    <link rel="icon" href="favicon15.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --grass-color: #288a42;
            --line-color: #ffffff;
        }
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            touch-action: none;
        }
        .grass {
            background-color: var(--grass-color);
            background-image:
                linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .custom-grass {
            background-size: cover;
            background-position: center;
        }
        .modal-backdrop {
            background-color: rgba(0,0,0,0.5);
            transition: opacity 0.3s ease;
        }
        .tile {
            touch-action: none;
            user-select: none;
        }
        .tile-on-field {
            position: absolute;
            cursor: grab;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .tile-on-panel {
            display: flex;
            align-items: center;
            cursor: grab;
        }
        #drag-clone {
            position: absolute;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.8;
        }
        .tile-svg-container {
            position: relative;
        }
        
        /* --- ここから修正 --- */
        /* 修正点1: マークの親要素をFlexboxコンテナに変更し、堅牢な中央揃えを実現 */
        .tile-on-field .mark {
            width: 18px;
            height: 18px;
            padding: 0;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            background-color: rgba(0,0,0,0.6);
        }
        
        /* 修正点2: アイコンの位置指定を削除し、Flexboxに中央揃えを委ねる */
         .tile-on-field .mark i {
            font-size: 12px;
        }
        /* --- ここまで修正 --- */

        .tile-mark-bottom-left {
            position: absolute;
            bottom: -4px;
            left: -4px;
        }
        .tile-mark-bottom-right {
            position: absolute;
            bottom: -4px;
            right: -4px;
        }
        .tile-mark-bottom-left .mark, .tile-mark-bottom-right .mark {
            width: 18px;
            height: 18px;
            padding: 0;
            border-radius: 9999px; /* 円形にする */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: white;
            background-color: rgba(0,0,0,0.7);
            border: 1px solid white;
        }
        .soccer-ball {
            position: absolute;
            width: 40px;
            height: 40px;
            cursor: grab;
            z-index: 40;
        }
        .dragging-source {
            opacity: 0.4;
            transition: opacity 0.2s;
        }
        body.dragging * {
            cursor: grabbing !important;
        }
        .drop-area {
             border: 2px dashed #ccc;
        }
        .drop-area.drag-over, .panel-tile-list.drag-over {
            border-color: #3498db;
            background-color: rgba(52, 152, 219, 0.1);
        }
        .drop-placeholder {
            height: 50px;
            background-color: rgba(52, 152, 219, 0.3);
            border: 2px dashed #3498db;
            border-radius: 0.25rem;
            margin: 4px 0;
        }
        .help-content ul ul {
            margin-top: 0.5rem;
            margin-left: 1rem;
            list-style-type: disc;
        }
    </style>
</head>
<body class="bg-gray-800 text-white h-screen flex flex-col select-none">

    <!-- トップパネル -->
    <header class="bg-gray-900 p-2 flex items-center justify-between shadow-lg">
        <h1 class="text-xl font-bold" data-lang="app_title">放り込みフォーメーション表</h1>
        <div class="flex items-center space-x-3">
            <button id="fullscreen-btn" class="bg-gray-700 hover:bg-gray-600 p-2 rounded-lg" title="Fullscreen"><i class="fas fa-expand"></i></button>
            <button id="save-all-btn" class="bg-gray-700 hover:bg-gray-600 p-2 rounded-lg" data-lang-title="save_all_data_title"><i class="fas fa-save"></i> <span data-lang="save_all_data">全体保存</span></button>
            <div class="relative">
                <button id="load-all-btn" class="bg-gray-700 hover:bg-gray-600 p-2 rounded-lg" data-lang-title="load_all_data_title"><i class="fas fa-folder-open"></i> <span data-lang="load_all_data">全体呼出</span></button>
                <input type="file" id="load-all-input" class="hidden" accept=".json">
            </div>
            <button id="help-btn" class="bg-gray-700 hover:bg-gray-600 p-2 rounded-lg" data-lang-title="help_title"><i class="fas fa-question-circle mr-1"></i><span data-lang="help"></span></button>
            <select id="lang-select" class="bg-gray-700 text-white p-2 rounded-lg">
                <option value="ja">日本語</option>
                <option value="en">English</option>
            </select>
        </div>
    </header>

    <!-- メインコンテンツ -->
    <div class="flex flex-1 overflow-hidden">
        <!-- 左チームパネル -->
        <aside id="team-panel-0" class="w-64 bg-gray-700 p-2 flex flex-col team-panel transition-colors duration-200" data-team-id="0">
        </aside>

        <!-- 中央フィールド -->
        <main id="field-container" class="flex-1 bg-gray-800 flex justify-center items-center p-4 relative overflow-hidden">
            <div id="field-area" class="relative grass shadow-2xl">
                <!-- ここにSVGでコートライン、タイル、ボールが描画される -->
            </div>
        </main>

        <!-- 右チームパネル -->
        <aside id="team-panel-1" class="w-64 bg-gray-700 p-2 flex flex-col team-panel transition-colors duration-200" data-team-id="1">
        </aside>
    </div>

    <!-- チーム別ファイル入力 -->
    <input type="file" id="load-team-input-0" class="hidden" accept=".json" data-team-id="0">
    <input type="file" id="load-team-input-1" class="hidden" accept=".json" data-team-id="1">


    <!-- 各種モーダルウィンドウ -->
    <!-- フィールド設定モーダル -->
    <div id="field-settings-modal" class="fixed inset-0 hidden items-center justify-center modal-backdrop z-50">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-96">
            <div class="flex justify-between items-center mb-4 relative">
                <h3 class="text-xl font-bold" data-lang="field_settings">フィールド設定</h3>
                <button class="close-modal-btn text-2xl font-bold text-gray-400 hover:text-white absolute -top-2 -right-2 w-8 h-8 flex items-center justify-center bg-gray-700 rounded-full">&times;</button>
            </div>
            <div class="space-y-4">
                <button id="toggle-orientation-btn" class="w-full bg-blue-600 hover:bg-blue-500 p-2 rounded" data-lang="toggle_pitch_orientation">ピッチ縦横切替</button>
                <button id="swap-sides-btn" class="w-full bg-green-600 hover:bg-green-500 p-2 rounded" data-lang="flip_pitch">ピッチ反転</button>
                <div class="grid grid-cols-2 gap-4">
                    <button id="change-ball-image-btn" class="w-full bg-yellow-600 hover:bg-yellow-500 p-2 rounded" data-lang="change_ball_image">ボール画像を変更</button>
                    <button id="reset-ball-image-btn" class="w-full bg-gray-600 hover:bg-gray-500 p-2 rounded" data-lang="reset_ball_image">初期化</button>
                </div>
                 <div class="grid grid-cols-2 gap-4">
                    <button id="change-grass-image-btn" class="w-full bg-teal-600 hover:bg-teal-500 p-2 rounded" data-lang="change_grass_image">芝生の画像を変更</button>
                    <button id="reset-grass-image-btn" class="w-full bg-gray-600 hover:bg-gray-500 p-2 rounded" data-lang="reset_grass_image">初期化</button>
                </div>
            </div>
        </div>
    </div>
    <input type="file" id="ball-image-input" class="hidden" accept="image/*">
    <input type="file" id="grass-image-input" class="hidden" accept="image/*">
    
    <!-- チーム設定モーダル -->
    <div id="team-settings-modal" class="fixed inset-0 hidden items-center justify-center modal-backdrop z-50">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-auto max-w-6xl max-h-[90vh] overflow-y-auto">
             <div class="flex justify-between items-center mb-4 relative">
                <h3 class="text-xl font-bold" data-lang="team_settings">チーム設定</h3>
                <button class="close-modal-btn text-2xl font-bold text-gray-400 hover:text-white absolute -top-2 -right-2 w-8 h-8 flex items-center justify-center bg-gray-700 rounded-full">&times;</button>
            </div>
            <div class="space-y-4">
                <div>
                    <label class="block mb-1" data-lang="team_name">チーム名</label>
                    <input id="team-name-input" type="text" class="w-full bg-gray-700 p-2 rounded">
                </div>
                <div class="grid grid-cols-2 gap-x-6">
                    <div>
                        <label class="block mb-1" data-lang="drop_name_list">選手名リストで一括登録</label>
                        <div id="name-list-drop-area" class="w-full h-20 bg-gray-700 rounded flex items-center justify-center drop-area">
                            <span data-lang="drop_name_list_here">ここに選手リスト(.txt)をドロップ</span>
                        </div>
                    </div>
                    <div>
                        <label class="block mb-1" data-lang="tile_bg_image_common">タイル背景画像（チーム共通）</label>
                        <div id="bg-image-drop-area" class="w-full h-20 bg-gray-700 rounded flex items-center justify-center drop-area">
                            <span data-lang="drop_image_here">ここに画像をドロップ</span>
                        </div>
                    </div>
                </div>

                <div class="space-y-2">
                     <label class="block mb-1" data-lang="bg_image_opacity">背景画像の透過度</label>
                     <div class="flex items-center">
                        <input id="bg-image-opacity-input" type="range" min="0" max="1" step="0.05" class="w-full mr-2">
                        <button id="clear-bg-image-btn" class="bg-red-600 hover:bg-red-500 p-1 rounded text-sm whitespace-nowrap" data-lang="clear_image">画像を消去</button>
                     </div>
                </div>
                
                <div>
                    <label class="block mb-1" data-lang="tile_bg_color">タイル背景色</label>
                    <input id="bg-color-input" type="color" class="w-full h-10 bg-gray-700 p-1 rounded">
                </div>

                <div class="grid grid-cols-2 gap-x-6 gap-y-4 pt-2 border-t border-gray-700">
                    <!-- Tile Shape and Size -->
                    <div class="col-span-2 grid grid-cols-2 gap-x-6 items-end">
                        <div>
                            <label class="block mb-1" data-lang="tile_shape">タイルの形</label>
                            <select id="tile-shape-select" class="w-full bg-gray-700 p-2 rounded">
                                <option value="circle" data-lang="circle">円</option>
                                <option value="hexagon" data-lang="hexagon">6角形</option>
                                <option value="octagon" data-lang="octagon">8角形</option>
                            </select>
                        </div>
                        <div>
                            <label class="block mb-1" data-lang="tile_size">タイルのサイズ</label>
                            <div class="flex items-center">
                                <input id="tile-size-input" type="range" min="30" max="80" step="1" class="w-full">
                                <span id="tile-size-value" class="ml-2 w-12 text-center">60px</span>
                            </div>
                        </div>
                    </div>

                    <!-- Border Color and Width -->
                    <div class="col-span-2 grid grid-cols-2 gap-x-6 items-end">
                        <div>
                            <label class="block mb-1" data-lang="tile_border_color">タイル枠線の色</label>
                            <input id="border-color-input" type="color" class="w-full h-10 bg-gray-700 p-1 rounded">
                        </div>
                        <div>
                            <label class="block mb-1" data-lang="border_width">枠線の太さ</label>
                            <div class="flex items-center">
                                <input id="border-width-input" type="range" min="0" max="10" step="0.5" class="w-full">
                                <span id="border-width-value" class="ml-2 w-12 text-center">2px</span>
                            </div>
                        </div>
                    </div>

                    <!-- Jersey Number Color and Size -->
                    <div class="col-span-2 grid grid-cols-2 gap-x-6 items-end">
                        <div>
                           <label class="block mb-1" data-lang="jersey_number_color">背番号の色</label>
                           <input id="number-color-input" type="color" class="w-full h-10 bg-gray-700 p-1 rounded">
                        </div>
                        <div>
                            <label class="block mb-1" data-lang="jersey_number_size">背番号のサイズ</label>
                            <div class="flex items-center">
                                <input id="number-size-input" type="range" min="10" max="40" step="1" class="w-full">
                                <span id="number-size-value" class="ml-2 w-12 text-center">20px</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-2 gap-x-6 gap-y-4 pt-4 border-t border-gray-700">
                     <!-- Player Name Color and Size -->
                    <div class="col-span-2 grid grid-cols-2 gap-x-6 items-end">
                        <div>
                           <label class="block mb-1" data-lang="player_name_color">選手名の色</label>
                           <input id="name-color-input" type="color" class="w-full h-10 bg-gray-700 p-1 rounded">
                        </div>
                        <div>
                            <label class="block mb-1" data-lang="player_name_size">選手名の文字サイズ</label>
                            <div class="flex items-center">
                                <input id="name-size-input" type="range" min="8" max="24" step="1" class="w-full">
                                <span id="name-size-value" class="ml-2 w-12 text-center">14px</span>
                            </div>
                        </div>
                    </div>
                     <!-- Affiliation Color and Size -->
                    <div class="col-span-2 grid grid-cols-2 gap-x-6 items-end">
                        <div>
                           <label class="block mb-1" data-lang="affiliation_color">所属の色</label>
                           <input id="affiliation-color-input" type="color" class="w-full h-10 bg-gray-700 p-1 rounded">
                        </div>
                        <div>
                            <label class="block mb-1" data-lang="affiliation_size">所属の文字サイズ</label>
                            <div class="flex items-center">
                                <input id="affiliation-size-input" type="range" min="8" max="20" step="1" class="w-full">
                                <span id="affiliation-size-value" class="ml-2 w-12 text-center">12px</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="flex justify-between items-end space-x-6 pt-4 border-t border-gray-700">
                    <!-- Display Settings -->
                    <div class="flex-1">
                        <label class="block mb-1" data-lang="display_settings_field">フィールドでの表示設定</label>
                        <div class="flex space-x-4 mt-2">
                            <label class="flex items-center"><input id="show-name-checkbox" type="checkbox" class="mr-2"> <span data-lang="show_player_name">選手名を表示</span></label>
                            <label class="flex items-center"><input id="show-affiliation-checkbox" type="checkbox" class="mr-2"> <span data-lang="show_affiliation">所属を表示</span></label>
                        </div>
                    </div>
                    <!-- Attack Direction -->
                    <div class="flex-1">
                        <label class="block mb-1" data-lang="attack_direction">攻める方向</label>
                        <select id="attack-direction-select" class="w-full bg-gray-700 p-2 rounded mt-1">
                            <option value="up" data-lang="up">上</option>
                            <option value="down" data-lang="down">下</option>
                            <option value="left" data-lang="left">左</option>
                            <option value="right" data-lang="right">右</option>
                            <option value="none" data-lang="none">非表示</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 個別タイル設定モーダル -->
    <div id="tile-settings-modal" class="fixed inset-0 hidden items-center justify-center modal-backdrop z-50">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-96">
            <div class="flex justify-between items-center mb-4 relative">
                <h3 class="text-xl font-bold" data-lang="tile_settings">タイル設定</h3>
                <button class="close-modal-btn text-2xl font-bold text-gray-400 hover:text-white absolute -top-2 -right-2 w-8 h-8 flex items-center justify-center bg-gray-700 rounded-full">&times;</button>
            </div>
            <div class="space-y-3">
                <div><label data-lang="player_name">選手名</label><input id="tile-name-input" type="text" class="w-full bg-gray-700 p-2 rounded mt-1"></div>
                <div><label data-lang="player_number">番号</label><input id="tile-number-input" type="number" min="0" class="w-full bg-gray-700 p-2 rounded mt-1"></div>
                <div>
                    <label data-lang="position">ポジション</label>
                    <select id="tile-position-select" class="w-full bg-gray-700 p-2 rounded mt-1">
                        <option value="">(なし)</option>
                        <option value="FW">FW</option>
                        <option value="MF">MF</option>
                        <option value="DF">DF</option>
                        <option value="GK">GK</option>
                    </select>
                </div>
                <div><label data-lang="affiliation">所属</label><input id="tile-affiliation-input" type="text" class="w-full bg-gray-700 p-2 rounded mt-1"></div>
            </div>
        </div>
    </div>
    
    <!-- フィールドタイル編集モーダル -->
    <div id="field-tile-edit-modal" class="fixed inset-0 hidden items-center justify-center modal-backdrop z-50">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6">
            <div class="flex justify-between items-center mb-4 relative">
                <h3 class="text-xl font-bold" data-lang="edit_marks">マーク編集</h3>
                <button class="close-modal-btn text-2xl font-bold text-gray-400 hover:text-white absolute -top-2 -right-2 w-8 h-8 flex items-center justify-center bg-gray-700 rounded-full">&times;</button>
            </div>
            <div class="grid grid-cols-2 gap-4">
                <div class="space-y-2">
                    <h4 class="font-bold" data-lang="cards">カード</h4>
                    <button data-mark-type="yellowCard" class="mark-btn w-full bg-yellow-400 text-black p-2 rounded" data-lang-title="yellow_card_mark">🟨</button>
                    <button data-mark-type="redCard" class="mark-btn w-full bg-red-600 p-2 rounded" data-lang-title="red_card_mark">🟥</button>
                </div>
                 <div class="space-y-2">
                    <h4 class="font-bold" data-lang="other">その他</h4>
                    <button data-mark-type="captain" class="mark-btn w-full bg-blue-500 p-2 rounded" data-lang-title="captain_mark">Ⓒ</button>
                    <button data-mark-type="goal" class="mark-btn w-full bg-green-500 p-2 rounded" data-lang-title="goal_mark">⚽</button>
                    <button data-mark-type="assist" class="mark-btn w-full bg-blue-600 text-white font-bold p-2 rounded" data-lang-title="assist_mark">A</button>
                    <button data-mark-type="substitution" class="mark-btn w-full bg-gray-500 p-2 rounded flex justify-center items-center" data-lang-title="substitution_mark"><svg width="16" height="16" viewBox="0 0 24 24"><path fill="green" d="M2,19.333L12,4.667L22,19.333H2z"/></svg></button>
                 </div>
                 <div class="col-span-2">
                    <button id="clear-marks-btn" class="w-full bg-gray-600 hover:bg-gray-500 p-2 rounded" data-lang="clear_all_marks">全マーク消去</button>
                 </div>
            </div>
        </div>
    </div>

    <!-- ヘルプモーダル -->
    <div id="help-modal" class="fixed inset-0 hidden items-center justify-center modal-backdrop z-50">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-1/2 max-w-2xl max-h-[80vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4 relative">
                <h3 class="text-xl font-bold" data-lang="help">操作説明</h3>
                <button class="close-modal-btn text-2xl font-bold text-gray-400 hover:text-white absolute -top-2 -right-2 w-8 h-8 flex items-center justify-center bg-gray-700 rounded-full">&times;</button>
            </div>
            <div class="prose prose-invert max-w-none space-y-4 help-content" data-lang-content="ja">
                <h4>1. 選手リストの作成と編集</h4>
                <ul>
                    <li><strong>選手の一括登録:</strong>
                        <ul>
                            <li>各行から「背番号」「ポジション」「所属」「名前」が自動で解釈されます。順番は自由で、省略も可能です。</li>
                            <li><strong>所属:</strong> <code>(Aチーム)</code> のように括弧で囲んでください。</li>
                            <li><strong>ポジション:</strong> <code>GK, DF, MF, FW</code> の大文字が認識されます。</li>
                            <li><strong>背番号:</strong> 1〜3桁の数字が認識されます。行内に複数ある場合は最初の数字が優先されます。</li>
                            <li><strong>例:</strong> <code>DF 5 長友 佑都 (インテル)</code></li>
                        </ul>
                    </li>
                    <li><strong>選手の個別操作:</strong>
                        <ul>
                            <li><strong>追加:</strong> チーム名横の <i class="fas fa-plus-circle"></i> ボタンをクリックします。</li>
                            <li><strong>編集:</strong> サイドパネルの選手タイルをダブルクリックすると、名前、背番号、ポジション、所属を個別に編集できます。</li>
                            <li><strong>削除:</strong> 選手タイルにカーソルを合わせると表示される「×」ボタンで削除できます。</li>
                            <li><strong>全選手削除:</strong> チーム名横の <i class="fas fa-trash"></i> ボタンでチームの全選手を削除します。</li>
                        </ul>
                    </li>
                    <li><strong>選手の並び替え:</strong>
                        <ul>
                            <li><strong>手動:</strong> サイドパネル内で選手タイルをドラッグ＆ドロップします。</li>
                            <li><strong>自動:</strong> チーム名横の <i class="fas fa-sort"></i> ボタンで「ポジション」→「背番号」→「カスタム(手動)」の順に整列します。</li>
                        </ul>
                    </li>
                    <li><strong>チーム全体の設定:</strong>
                        <ul>
                            <li>チーム名横の <i class="fas fa-cog"></i> ボタンから、チーム名、タイルの形状・色・サイズ、枠線、背番号や選手名の表示設定などを一括で変更できます。</li>
                        </ul>
                    </li>
                </ul>

                <h4>2. フィールドの操作とタイルの編集</h4>
                <ul>
                    <li><strong>タイルの配置:</strong> サイドパネルの選手タイルをドラッグしてフィールドに配置します。フィールド内外への移動は自由です。</li>
                    <li><strong>ボールの移動:</strong> フィールド上のサッカーボールをドラッグして移動できます。</li>
                    <li><strong>タイルマークの編集:</strong> フィールド上の選手タイルをダブルクリックすると、キャプテンマーク(Ⓒ)、カード(🟨🟥)、ゴール(⚽)などのマークを付けられます。</li>
                    <li><strong>フィールド設定:</strong> フィールドエリアをダブルクリックすると、コートの縦横切替、ピッチ反転、ボールや芝生の画像を変更できます。</li>
                </ul>

                <h4>3. 保存と呼出</h4>
                <ul>
                    <li><strong>データ保存・呼出:</strong>
                        <ul>
                            <li><strong>チーム別:</strong> サイドパネルの <i class="fas fa-save"></i> / <i class="fas fa-folder-open"></i> ボタンから、そのチームの選手リストと設定を保存・呼出できます。</li>
                            <li><strong>全体:</strong> トップメニューの <i class="fas fa-save"></i> / <i class="fas fa-folder-open"></i> ボタンから、両チームとフィールドの状態をすべて含んだ全体のデータを保存・呼出できます。</li>
                        </ul>
                    </li>
                </ul>
            </div>
             <div class="prose prose-invert max-w-none space-y-4 help-content" data-lang-content="en" style="display: none;">
                <h4>1. Creating and Editing Player Lists</h4>
                <ul>
                    <li><strong>Bulk Player Registration:</strong>
                        <ul>
                            <li>"Number", "Position", "Affiliation", and "Name" are automatically interpreted from each line. The order is flexible, and items can be omitted.</li>
                            <li><strong>Affiliation:</strong> Enclose in parentheses, like <code>(Team A)</code>.</li>
                            <li><strong>Position:</strong> Recognizes <code>GK, DF, MF, FW</code> (uppercase).</li>
                            <li><strong>Number:</strong> Recognizes 1 to 3-digit numbers. If multiple numbers exist, the first one is used.</li>
                            <li><strong>Example:</strong> <code>DF 5 John Doe (Team A)</code></li>
                        </ul>
                    </li>
                    <li><strong>Individual Player Actions:</strong>
                        <ul>
                            <li><strong>Add:</strong> Click the <i class="fas fa-plus-circle"></i> icon next to the team name.</li>
                            <li><strong>Edit:</strong> Double-click a player tile in the side panel to edit their name, number, position, and affiliation.</li>
                            <li><strong>Delete:</strong> Hover over a player tile and click the '×' button that appears.</li>
                            <li><strong>Clear All Players:</strong> Click the <i class="fas fa-trash"></i> icon to delete all players from the team.</li>
                        </ul>
                    </li>
                    <li><strong>Reordering Players:</strong>
                        <ul>
                            <li><strong>Manual:</strong> Drag and drop player tiles within the side panel.</li>
                            <li><strong>Automatic:</strong> Click the <i class="fas fa-sort"></i> icon to sort by "Position" -> "Number" -> "Custom (manual)".</li>
                        </ul>
                    </li>
                    <li><strong>Team-wide Settings:</strong>
                        <ul>
                            <li>Click the <i class="fas fa-cog"></i> icon to change the team name, tile shape, colors, size, borders, and display settings for names and numbers.</li>
                        </ul>
                    </li>
                </ul>

                <h4>2. Field Operations and Tile Editing</h4>
                <ul>
                    <li><strong>Placing Tiles:</strong> Drag player tiles from the side panel onto the field. You can move them freely between the field and the panel.</li>
                    <li><strong>Moving the Ball:</strong> Drag the soccer ball on the field to position it.</li>
                    <li><strong>Editing Tile Marks:</strong> Double-click a player tile on the field to add marks like captain (Ⓒ), cards (🟨🟥), goals (⚽), etc.</li>
                    <li><strong>Field Settings:</strong> Double-click the field area to toggle orientation, flip the pitch, and change the ball or grass images.</li>
                </ul>

                <h4>3. Saving and Loading</h4>
                <ul>
                    <li><strong>Save/Load Data:</strong>
                        <ul>
                            <li><strong>By Team:</strong> Use the <i class="fas fa-save"></i> / <i class="fas fa-folder-open"></i> icons in the side panel to save or load a specific team's roster and settings.</li>
                            <li><strong>All Data:</strong> Use the <i class="fas fa-save"></i> / <i class="fas fa-folder-open"></i> icons in the top menu to save or load the entire state, including both teams and the field setup.</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
    </div>

    <!-- 確認モーダル -->
    <div id="confirm-modal" class="fixed inset-0 hidden items-center justify-center modal-backdrop z-50">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-96">
            <h3 id="confirm-modal-title" class="text-xl font-bold mb-4" data-lang="confirm_title">確認</h3>
            <p id="confirm-modal-message" class="mb-6"></p>
            <div class="flex justify-end space-x-4">
                <button id="confirm-modal-cancel-btn" class="bg-gray-600 hover:bg-gray-500 px-4 py-2 rounded" data-lang="cancel">いいえ</button>
                <button id="confirm-modal-ok-btn" class="bg-red-600 hover:bg-red-500 px-4 py-2 rounded" data-lang="confirm">はい</button>
            </div>
        </div>
    </div>


    <script>
    document.addEventListener('DOMContentLoaded', () => {

        let wasFullscreenBeforeFileLoad = false;

        // --- 定数定義 ---
        const FIELD_ASPECT_RATIO = 105 / 68;
        const BALL_SIZE = 40;

        // --- I18N (国際化) ---
        const translations = {
            ja: {
                app_title: "放り込みフォーメーション表", save_all_data: "全体保存", load_all_data: "全体呼出",
                save_all_data_title: "全体データを保存", load_all_data_title: "全体データを読み込み", help_title: "ヘルプ",
                field_settings: "フィールド設定", toggle_pitch_orientation: "ピッチ縦横切替", flip_pitch: "ピッチ反転", team_settings: "チーム設定",
                team_name: "チーム名", tile_shape: "タイルの形", circle: "円", hexagon: "6角形", octagon: "8角形",
                tile_border_color: "タイル枠線の色", border_width: "枠線の太さ", tile_bg_color: "タイル背景色", tile_bg_image_common: "タイル背景画像（チーム共通）", drop_image_here: "ここに画像をドロップ",
                clear_image: "画像を消去", jersey_number_color: "背番号の色", jersey_number_size: "背番号のサイズ", display_settings_field: "フィールドでの表示設定",
                show_player_name: "選手名を表示", show_affiliation: "所属を表示", attack_direction: "攻める方向", up: "上", down: "下", left: "左", right: "右", none: "非表示",
                tile_settings: "タイル設定", player_name: "選手名", player_number: "番号", position: "ポジション", affiliation: "所属",
                edit_marks: "マーク編集", cards: "カード", other: "その他", clear_all_marks: "全マーク消去", help: "操作説明",
                add_player: "選手追加", remove_player: "選手削除", tile_size: "タイルのサイズ", change_ball_image: "ボール画像を変更", reset_ball_image: "初期化", change_grass_image: "芝生の画像を変更", reset_grass_image: "初期化",
                drop_name_list: "選手名リストで一括登録", drop_name_list_here: "ここに選手リスト(.txt)をドロップ",
                yellow_card_mark: "イエローカード", red_card_mark: "レッドカード", captain_mark: "キャプテン", goal_mark: "ゴール", assist_mark: "アシスト", substitution_mark: "途中出場",
                confirm_title: "確認", confirm_delete_message: "本当にこの選手を削除しますか？", cancel: "いいえ", confirm: "はい",
                sort_players: "選手を整列",
                save_team: "チーム保存", load_team: "チーム呼出",
                bg_image_opacity: "背景画像の透過度",
                player_name_color: "選手名の色",
                player_name_size: "選手名の文字サイズ",
                affiliation_color: "所属の色",
                affiliation_size: "所属の文字サイズ",
                clear_all_players: "全選手を消去",
                confirm_clear_all_players_message: "本当にこのチームの全選手を削除しますか？"
            },
            en: {
                app_title: "Formation Board", save_all_data: "Save All", load_all_data: "Load All",
                save_all_data_title: "Save All Data", load_all_data_title: "Load All Data", help_title: "Help",
                field_settings: "Field Settings", toggle_pitch_orientation: "Toggle Pitch Orientation", flip_pitch: "Flip Pitch", team_settings: "Team Settings",
                team_name: "Team Name", tile_shape: "Tile Shape", circle: "Circle", hexagon: "Hexagon", octagon: "Octagon",
                tile_border_color: "Tile Border Color", border_width: "Border Width", tile_bg_color: "Tile Background Color", tile_bg_image_common: "Tile Background Image (Team)", drop_image_here: "Drop image here",
                clear_image: "Clear Image", jersey_number_color: "Jersey Number Color", jersey_number_size: "Jersey Number Size", display_settings_field: "Display Settings (on Field)",
                show_player_name: "Show Player Name", show_affiliation: "Show Affiliation", attack_direction: "Attack Direction", up: "Up", down: "Down", left: "Left", right: "Right", none: "Hide",
                tile_settings: "Tile Settings", player_name: "Player Name", player_number: "Number", position: "Position", affiliation: "Affiliation",
                edit_marks: "Edit Marks", cards: "Cards", other: "Other", clear_all_marks: "Clear All Marks", help: "Help",
                add_player: "Add Player", remove_player: "Remove Player", tile_size: "Tile Size", change_ball_image: "Change Ball Image", reset_ball_image: "Reset", change_grass_image: "Change Grass Image", reset_grass_image: "Reset",
                drop_name_list: "Bulk Register with Name List", drop_name_list_here: "Drop player name text file (.txt) here",
                yellow_card_mark: "Yellow Card", red_card_mark: "Red Card", captain_mark: "Captain", goal_mark: "Goal", assist_mark: "Assist", substitution_mark: "Substitution",
                confirm_title: "Confirmation", confirm_delete_message: "Are you sure you want to delete this player?", cancel: "No", confirm: "Yes",
                sort_players: "Sort Players",
                save_team: "Save Team", load_team: "Load Team",
                bg_image_opacity: "Background Image Opacity",
                player_name_color: "Player Name Color",
                player_name_size: "Player Name Size",
                affiliation_color: "Affiliation Color",
                affiliation_size: "Affiliation Size",
                clear_all_players: "Clear All Players",
                confirm_clear_all_players_message: "Are you sure you want to delete all players from this team?"
            }
        };

        let currentLang = 'ja';

        function t(key) {
            return translations[currentLang][key] || key;
        }

        function updateLanguageUI() {
            document.querySelectorAll('[data-lang]').forEach(el => {
                const key = el.dataset.lang;
                el.textContent = t(key);
            });
            document.querySelectorAll('[data-lang-title]').forEach(el => {
                const key = el.dataset.langTitle;
                el.title = t(key);
            });
            
            document.querySelectorAll('.help-content').forEach(el => {
                el.style.display = el.dataset.langContent === currentLang ? 'block' : 'none';
            });
        }


        // --- 状態管理 ---
        let appState = {};
        
        const defaultAppState = {
            teams: [
                {
                    name: 'Team A',
                    sortState: 'custom',
                    settings: { 
                        shape: 'circle', borderColor: '#ffffff', borderWidth: 2, bgColor: '#ff0000', 
                        bgImage: null, bgImageOpacity: 1, 
                        numberColor: '#ffffff', numberSize: 20, 
                        showName: true, showAffiliation: false, 
                        nameColor: '#ffffff', nameSize: 14,
                        affiliationColor: '#dddddd', affiliationSize: 12,
                        attackDirection: 'right', tileSize: 60 
                    },
                    tiles: [],
                },
                {
                    name: 'Team B',
                    sortState: 'custom',
                    settings: { 
                        shape: 'circle', borderColor: '#ffffff', borderWidth: 2, bgColor: '#0000ff', 
                        bgImage: null, bgImageOpacity: 1, 
                        numberColor: '#ffffff', numberSize: 20, 
                        showName: true, showAffiliation: false, 
                        nameColor: '#ffffff', nameSize: 14,
                        affiliationColor: '#dddddd', affiliationSize: 12,
                        attackDirection: 'left', tileSize: 60 
                    },
                    tiles: [],
                }
            ],
            field: {
                orientation: 'horizontal', // or 'vertical'
                grassImage: 'https://placehold.co/1050x680/288a42/288a42?text=+',
                ball: { 
                    x: 50, 
                    y: 50,
                    imageSrc: 'https://placehold.co/100x100/ffffff/000000?text=⚽'
                }
            },
            lang: 'ja'
        };
        
        function createDefaultTile(id, number, order) {
            return {
                id: id,
                number: number,
                name: `Player ${number}`,
                position: '',
                affiliation: '',
                order: order,
                location: 'panel', // 'panel' or 'field'
                x: null, // percentage
                y: null, // percentage
                marks: {
                    yellowCard: 0,
                    redCard: 0,
                    captain: 0,
                    goal: 0,
                    assist: 0,
                    substitution: 0
                }
            };
        }

        function initializeState() {
            appState = JSON.parse(JSON.stringify(defaultAppState)); // Deep copy
            currentLang = appState.lang;
            document.getElementById('lang-select').value = currentLang;
        }

        // --- ドラッグ&ドロップ管理 (リファクタリング版) ---
        const dragged = {
            type: null, // 'tile-on-field', 'panel-tile', 'ball'
            element: null, // ドラッグ中のゴースト要素
            sourceElement: null, // ドラッグ元の要素
            
            // 共通
            teamId: null,
            tileId: null,

            // マウス/タッチ位置
            startX: 0,
            startY: 0,
            offsetX: 0,
            offsetY: 0,

            // 移動前の位置
            initialX: 0,
            initialY: 0,
        };

        function resetDraggedState() {
            if (dragged.sourceElement) {
                dragged.sourceElement.classList.remove('dragging-source');
            }
            if (dragged.element) {
                dragged.element.remove();
            }
            
            const placeholder = document.querySelector('.drop-placeholder');
            if(placeholder) placeholder.remove();

            document.body.classList.remove('dragging');

            dragged.type = null;
            dragged.element = null;
            dragged.sourceElement = null;
            dragged.teamId = null;
            dragged.tileId = null;
        }

        // --- SVGヘルパー ---
        function createTileSVG(team, tile) {
            const s = team.settings;
            const size = s.tileSize || 60;
            const half = size / 2;
            const strokeWidth = s.borderWidth;
            let path = '';

            switch (s.shape) {
                case 'hexagon':
                    path = `M${half},${strokeWidth} L${size-strokeWidth},${size*0.25} L${size-strokeWidth},${size*0.75} L${half},${size-strokeWidth} L${strokeWidth},${size*0.75} L${strokeWidth},${size*0.25} Z`;
                    break;
                case 'octagon':
                    path = `M${size*0.3},${strokeWidth} L${size*0.7},${strokeWidth} L${size-strokeWidth},${size*0.3} L${size-strokeWidth},${size*0.7} L${size*0.7},${size-strokeWidth} L${size*0.3},${size-strokeWidth} L${strokeWidth},${size*0.7} L${strokeWidth},${size*0.3} Z`;
                    break;
                case 'circle':
                default:
                    path = `M${half},${half} m-${half-strokeWidth},0 a${half-strokeWidth},${half-strokeWidth} 0 1,0 ${size-strokeWidth*2},0 a${half-strokeWidth},${half-strokeWidth} 0 1,0 -${size-strokeWidth*2},0`;
                    break;
            }
            
            const clipId = `clip-${tile.id}`;
            const patternId = `pattern-${tile.id}`;
            
            return `
                <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" class="tile-svg">
                    <defs>
                        <clipPath id="${clipId}">
                            <path d="${path}" />
                        </clipPath>
                        ${s.bgImage ? `
                        <pattern id="${patternId}" patternUnits="userSpaceOnUse" width="${size}" height="${size}">
                            <image href="${s.bgImage}" x="0" y="0" width="${size}" height="${size}" preserveAspectRatio="xMidYMid slice" />
                        </pattern>
                        ` : ''}
                    </defs>
                    <g clip-path="url(#${clipId})">
                        <rect x="0" y="0" width="${size}" height="${size}" fill="${s.bgColor}" />
                        ${s.bgImage ? `<rect x="0" y="0" width="${size}" height="${size}" fill="url(#${patternId})" style="opacity: ${s.bgImageOpacity};" />` : ''}
                    </g>
                    <path d="${path}" fill="none" stroke="${s.borderColor}" stroke-width="${strokeWidth}" />
                    <text x="50%" y="50%" dy="0.1em" dominant-baseline="middle" text-anchor="middle" fill="${s.numberColor}" font-size="${s.numberSize}px" font-weight="bold" style="pointer-events: none; text-shadow: 0 0 5px black, 0 0 3px black;">${tile.number}</text>
                </svg>
            `;
        }
        
        // --- 描画ロジック ---
        function renderAll() {
            renderTeamPanels();
            renderField();
            updateLanguageUI();
        }

        function renderTeamPanels() {
            appState.teams.forEach((team, teamId) => {
                const panel = document.getElementById(`team-panel-${teamId}`);
                const panelTileList = panel.querySelector('.panel-tile-list') || document.createElement('div');
                if (!panel.querySelector('.panel-tile-list')) {
                    panelTileList.className = 'flex-1 overflow-y-auto space-y-2 pr-1 panel-tile-list';
                }

                const panelTiles = team.tiles.filter(t => t.location === 'panel').sort((a, b) => a.order - b.order);
                
                panel.innerHTML = `
                    <div class="flex items-center justify-between mb-2">
                        <h2 class="text-lg font-bold truncate">${team.name}</h2>
                        <div class="flex items-center">
                           <button class="team-settings-btn p-1 hover:text-yellow-400" data-team-id="${teamId}" title="${t('team_settings')}"><i class="fas fa-cog"></i></button>
                           <button class="save-team-btn p-1 hover:text-green-400" data-team-id="${teamId}" title="${t('save_team')}"><i class="fas fa-save"></i></button>
                           <button class="load-team-btn p-1 hover:text-blue-400" data-team-id="${teamId}" title="${t('load_team')}"><i class="fas fa-folder-open"></i></button>
                           <button class="sort-team-btn p-1 hover:text-blue-400" data-team-id="${teamId}" title="${t('sort_players')}"><i class="fas fa-sort"></i></button>
                           <button class="add-player-btn p-1 hover:text-green-400" data-team-id="${teamId}" title="${t('add_player')}"><i class="fas fa-plus-circle"></i></button>
                           <button class="clear-players-btn p-1 hover:text-red-400" data-team-id="${teamId}" title="${t('clear_all_players')}"><i class="fas fa-trash"></i></button>
                        </div>
                    </div>
                `;
                
                panelTileList.innerHTML = panelTiles.map(tile => `
                    <div class="tile tile-on-panel bg-gray-800 p-1 rounded relative group" data-team-id="${teamId}" data-tile-id="${tile.id}">
                        ${createTileSVG(team, tile)}
                        <div class="ml-2 flex-1 truncate">
                            <div class="font-semibold flex items-center">
                                <span>${tile.name}</span>
                                ${tile.position ? `<span class="ml-2 text-xs text-gray-400 bg-gray-700 px-1 rounded">${tile.position}</span>` : ''}
                            </div>
                            ${tile.affiliation ? `<div class="text-xs text-gray-400">${tile.affiliation}</div>` : ''}
                        </div>
                        <button class="delete-tile-btn absolute -top-1 -right-1 w-5 h-5 bg-red-600 text-white rounded-full hidden group-hover:flex items-center justify-center text-xs" data-team-id="${teamId}" data-tile-id="${tile.id}">&times;</button>
                    </div>
                `).join('');
                panel.appendChild(panelTileList);
            });
        }

        function renderField() {
            const container = document.getElementById('field-container');
            const area = document.getElementById('field-area');
            const containerRect = container.getBoundingClientRect();
            
            const aspectRatio = FIELD_ASPECT_RATIO;
            let fieldWidth, fieldHeight;

            if (appState.field.orientation === 'horizontal') {
                fieldWidth = Math.min(containerRect.width - 40, (containerRect.height - 40) * aspectRatio);
                fieldHeight = fieldWidth / aspectRatio;
            } else { // vertical
                fieldHeight = Math.min(containerRect.height - 40, (containerRect.width - 40) * aspectRatio);
                fieldWidth = fieldHeight / aspectRatio;
            }
            
            area.style.width = `${fieldWidth}px`;
            area.style.height = `${fieldHeight}px`;

            if (appState.field.grassImage) {
                area.style.backgroundImage = `url(${appState.field.grassImage})`;
                area.classList.add('custom-grass');
                area.classList.remove('grass');
            } else {
                area.style.backgroundImage = '';
                area.classList.remove('custom-grass');
                area.classList.add('grass');
            }

            area.innerHTML = getFieldLinesSVG(fieldWidth, fieldHeight);
            
            const ball = document.createElement('div');
            ball.className = 'soccer-ball';
            const ballX = appState.field.ball.x / 100 * fieldWidth;
            const ballY = appState.field.ball.y / 100 * fieldHeight;
            ball.style.width = `${BALL_SIZE}px`;
            ball.style.height = `${BALL_SIZE}px`;
            ball.style.left = `calc(${ballX}px - ${BALL_SIZE / 2}px)`;
            ball.style.top = `calc(${ballY}px - ${BALL_SIZE / 2}px)`;
            
            const ballImg = document.createElement('img');
            ballImg.src = appState.field.ball.imageSrc;
            ballImg.alt = 'Soccer Ball';
            ballImg.style.width = '100%';
            ballImg.style.height = '100%';
            ballImg.style.borderRadius = '50%';
            ballImg.style.pointerEvents = 'none';
            ball.appendChild(ballImg);

            area.appendChild(ball);

            appState.teams.forEach((team, teamId) => {
                const tileSize = team.settings.tileSize || 60;
                team.tiles.filter(t => t.location === 'field').forEach(tile => {
                    const el = document.createElement('div');
                    el.className = 'tile tile-on-field';
                    el.dataset.teamId = teamId;
                    el.dataset.tileId = tile.id;
                    el.style.left = `calc(${tile.x}% - ${tileSize/2}px)`;
                    el.style.top = `calc(${tile.y}% - ${tileSize/2}px)`;
                    
                    const marks = tile.marks;
                    const s = team.settings;
                    const isHorizontal = appState.field.orientation === 'horizontal';
                    const attackDir = s.attackDirection;
                    const flipMarks = isHorizontal && attackDir === 'right';

                    const MARK_SIZE = 18;
                    const MARK_GAP = 2;
                    const TOTAL_MARK_SIZE = MARK_SIZE + MARK_GAP;

                    // Font Awesome Icons
                    const captainSVG = `<div class="mark" style="background-color: #3b82f6;"><i class="fas fa-copyright text-white"></i></div>`;
                    const yellowCardSVG = `<div class="mark" style="background-color: #facc15;"></div>`;
                    const redCardSVG = `<div class="mark" style="background-color: #dc2626;"></div>`;
                    const goalSVG = `<div class="mark" style="background-color: #22c55e;"><i class="fas fa-futbol text-white"></i></div>`;
                    const assistSVG = `<div class="mark" style="background-color: #2563eb;"><i class="fas fa-font text-white"></i></div>`;
                    
                    // Separate marks into categories
                    let captainMarkArray = [];
                    if (marks.captain > 0) captainMarkArray.push(captainSVG);
                    
                    let cardMarks = [];
                    if (marks.yellowCard > 0) cardMarks.push(yellowCardSVG);
                    if (marks.redCard > 0) cardMarks.push(redCardSVG);
                    
                    let goalMarks = [];
                    if (marks.goal > 0) for (let i = 0; i < marks.goal; i++) goalMarks.push(goalSVG);
                    
                    let assistMarks = [];
                    if (marks.assist > 0) for (let i = 0; i < marks.assist; i++) assistMarks.push(assistSVG);

                    let leftMarksHTML = '';
                    let rightMarksHTML = '';

                    // Vertical Marks (Captain, Cards)
                    let leftVOffset = 0;
                    let rightVOffset = 0;

                    const verticalMarksOnLeft = flipMarks ? cardMarks : captainMarkArray;
                    const verticalMarksOnRight = flipMarks ? captainMarkArray : cardMarks;
                    const otherMarksContainerSide = flipMarks ? 'left' : 'right';

                    verticalMarksOnLeft.forEach(mark => {
                        leftMarksHTML += `<div style="position: absolute; top: ${leftVOffset}px; left: -${MARK_SIZE}px;">${mark}</div>`;
                        leftVOffset += TOTAL_MARK_SIZE;
                    });
                    
                    verticalMarksOnRight.forEach(mark => {
                        rightMarksHTML += `<div style="position: absolute; top: ${rightVOffset}px; right: -${MARK_SIZE}px;">${mark}</div>`;
                        rightVOffset += TOTAL_MARK_SIZE;
                    });
                    
                    let horizontalVOffset = (otherMarksContainerSide === 'left') ? leftVOffset : rightVOffset;

                    if(goalMarks.length > 0) {
                        let hOffset = 0;
                        goalMarks.forEach(mark => {
                            const sideProperty = otherMarksContainerSide === 'left' ? `left: -${MARK_SIZE + hOffset}px;` : `right: -${MARK_SIZE + hOffset}px;`;
                            const html = `<div style="position: absolute; top: ${horizontalVOffset}px; ${sideProperty}">${mark}</div>`;
                             if(otherMarksContainerSide === 'left') leftMarksHTML += html; else rightMarksHTML += html;
                            hOffset += TOTAL_MARK_SIZE;
                        });
                        horizontalVOffset += TOTAL_MARK_SIZE;
                    }
                    if(assistMarks.length > 0) {
                        let hOffset = 0;
                        assistMarks.forEach(mark => {
                           const sideProperty = otherMarksContainerSide === 'left' ? `left: -${MARK_SIZE + hOffset}px;` : `right: -${MARK_SIZE + hOffset}px;`;
                           const html = `<div style="position: absolute; top: ${horizontalVOffset}px; ${sideProperty}">${mark}</div>`;
                           if(otherMarksContainerSide === 'left') leftMarksHTML += html; else rightMarksHTML += html;
                           hOffset += TOTAL_MARK_SIZE;
                        });
                    }

                    let subMarkHTML = '';
                    if(marks.substitution > 0) {
                        const subMarkClass = flipMarks ? 'tile-mark-bottom-right' : 'tile-mark-bottom-left';
                        subMarkHTML = `<div class="${subMarkClass}"><div class="mark" style="background-color: #6b7280;"><svg width="12" height="12" viewBox="0 0 24 24"><path fill="green" d="M2,19.333L12,4.667L22,19.333H2z"/></svg></div></div>`;
                    }

                    let arrowHTML = getArrowSVG(s);

                    el.innerHTML = `
                        <div class="tile-svg-container">
                            ${createTileSVG(team, tile)}
                            ${leftMarksHTML}
                            ${rightMarksHTML}
                            ${subMarkHTML}
                            ${arrowHTML}
                        </div>
                        <div class="mt-1 text-center" style="text-shadow: 0 0 3px black;">
                            ${s.showName ? `<div class="font-semibold" style="color: ${s.nameColor}; font-size: ${s.nameSize}px;">${tile.name}</div>` : ''}
                            ${s.showAffiliation ? `<div class="text-xs" style="color: ${s.affiliationColor}; font-size: ${s.affiliationSize}px;">${tile.affiliation}</div>` : ''}
                        </div>
                    `;
                    area.appendChild(el);
                });
            });
        }
        
        function getArrowSVG(settings) {
            let path = '';
            let wrapperStyle = '';
            
            const fieldOrientation = appState.field.orientation;
            let dir = settings.attackDirection;

            if (dir === 'none') return '';
            
            if (fieldOrientation === 'vertical') {
                if(dir === 'right') dir = 'down';
                if(dir === 'left') dir = 'up';
            }

            switch(dir) {
                case 'up':
                    wrapperStyle = 'top: -20px; left: 50%; margin-left: -12px;';
                    path = 'M12 2 L2 22 L22 22 Z';
                    break;
                case 'down':
                    wrapperStyle = 'bottom: -20px; left: 50%; margin-left: -12px;';
                    path = 'M12 22 L2 2 L22 2 Z';
                    break;
                case 'left':
                    wrapperStyle = 'left: -20px; top: 50%; margin-top: -12px;';
                    path = 'M2 12 L22 2 L22 22 Z';
                    break;
                case 'right':
                    wrapperStyle = 'right: -20px; top: 50%; margin-top: -12px;';
                    path = 'M22 12 L2 2 L2 22 Z';
                    break;
            }
            
            return `<div style="position: absolute; ${wrapperStyle} width: 24px; height: 24px;">
                        <svg width="24" height="24" viewBox="0 0 24 24">
                            <path d="${path}" fill="${settings.borderColor}" />
                        </svg>
                    </div>`;
        }
        
        function getFieldLinesSVG(w, h) {
            if (appState.field.orientation === 'vertical') {
                return `
                <svg width="${w}" height="${h}" style="position:absolute; top:0; left:0; pointer-events:none;">
                    <rect x="0" y="0" width="${w}" height="${h}" fill="none" stroke="var(--line-color)" stroke-width="2"/>
                    <line x1="0" y1="${h/2}" x2="${w}" y2="${h/2}" stroke="var(--line-color)" stroke-width="2"/>
                    <circle cx="${w/2}" cy="${h/2}" r="${Math.min(w,h) * 0.15}" fill="none" stroke="var(--line-color)" stroke-width="2"/>
                    <circle cx="${w/2}" cy="${h/2}" r="3" fill="var(--line-color)"/>
                    <rect x="${w*0.2}" y="0" width="${w*0.6}" height="${h*0.15}" fill="none" stroke="var(--line-color)" stroke-width="2"/>
                    <rect x="${w*0.2}" y="${h - h*0.15}" width="${w*0.6}" height="${h*0.15}" fill="none" stroke="var(--line-color)" stroke-width="2"/>
                    <rect x="${w*0.35}" y="0" width="${w*0.3}" height="${h*0.07}" fill="none" stroke="var(--line-color)" stroke-width="2"/>
                    <rect x="${w*0.35}" y="${h-h*0.07}" width="${w*0.3}" height="${h*0.07}" fill="none" stroke="var(--line-color)" stroke-width="2"/>
                    <path d="M${w/2-w*0.15} ${h*0.15} A ${w*0.1} ${w*0.1} 0 0 0 ${w/2+w*0.15} ${h*0.15}" fill="none" stroke="var(--line-color)" stroke-width="2"/>
                    <path d="M${w/2-w*0.15} ${h-h*0.15} A ${w*0.1} ${w*0.1} 0 0 1 ${w/2+w*0.15} ${h-h*0.15}" fill="none" stroke="var(--line-color)" stroke-width="2"/>
                </svg>
                `;
            } else { // horizontal
                return `
                <svg width="${w}" height="${h}" style="position:absolute; top:0; left:0; pointer-events:none;">
                    <rect x="0" y="0" width="${w}" height="${h}" fill="none" stroke="var(--line-color)" stroke-width="2"/>
                    <line x1="${w/2}" y1="0" x2="${w/2}" y2="${h}" stroke="var(--line-color)" stroke-width="2"/>
                    <circle cx="${w/2}" cy="${h/2}" r="${Math.min(w,h) * 0.15}" fill="none" stroke="var(--line-color)" stroke-width="2"/>
                    <circle cx="${w/2}" cy="${h/2}" r="3" fill="var(--line-color)"/>
                    <rect x="0" y="${h*0.2}" width="${w*0.15}" height="${h*0.6}" fill="none" stroke="var(--line-color)" stroke-width="2"/>
                    <rect x="${w - w*0.15}" y="${h*0.2}" width="${w*0.15}" height="${h*0.6}" fill="none" stroke="var(--line-color)" stroke-width="2"/>
                    <rect x="0" y="${h*0.35}" width="${w*0.07}" height="${h*0.3}" fill="none" stroke="var(--line-color)" stroke-width="2"/>
                    <rect x="${w - w*0.07}" y="${h*0.35}" width="${w*0.07}" height="${h*0.3}" fill="none" stroke="var(--line-color)" stroke-width="2"/>
                    <path d="M${w*0.15} ${h/2-h*0.15} A ${h*0.1} ${h*0.1} 0 0 1 ${w*0.15} ${h/2+h*0.15}" fill="none" stroke="var(--line-color)" stroke-width="2"/>
                    <path d="M${w-w*0.15} ${h/2-h*0.15} A ${h*0.1} ${h*0.1} 0 0 0 ${w-w*0.15} ${h/2+h*0.15}" fill="none" stroke="var(--line-color)" stroke-width="2"/>
                </svg>
                `;
            }
        }

        // --- モーダル制御 ---
        let activeModal = null;
        let activeModalData = {};
        let confirmCallback = null;

        function showModal(modalId, data = {}) {
            activeModal = document.getElementById(modalId);
            activeModalData = data;
            activeModal.classList.remove('hidden');
            activeModal.classList.add('flex');
            if (modalId === 'team-settings-modal') loadTeamSettings();
            if (modalId === 'tile-settings-modal') loadTileSettings();
        }
        
        function showConfirmModal(message, callback) {
            const modal = document.getElementById('confirm-modal');
            document.getElementById('confirm-modal-message').textContent = message;
            confirmCallback = callback;
            modal.classList.remove('hidden');
            modal.classList.add('flex');
        }

        function hideModals() {
            document.querySelectorAll('.modal-backdrop').forEach(m => {
                m.classList.add('hidden');
                m.classList.remove('flex');
            });
            activeModal = null;
            activeModalData = {};
            confirmCallback = null;
        }

        document.querySelectorAll('.close-modal-btn').forEach(btn => btn.addEventListener('click', hideModals));
        document.querySelectorAll('.modal-backdrop').forEach(modal => {
            modal.addEventListener('click', (e) => { if (e.target === modal) hideModals(); });
        });

        // --- イベントリスナー ---
        let wasJustDragged = false;

        function setupEventListeners() {
            // Top panel buttons
            document.getElementById('fullscreen-btn').addEventListener('click', () => {
                if (!document.fullscreenElement) document.documentElement.requestFullscreen();
                else document.exitFullscreen();
            });
            document.getElementById('save-all-btn').addEventListener('click', () => saveState('all'));
            
            document.getElementById('load-all-btn').addEventListener('click', () => {
                document.getElementById('load-all-input').click();
            });
            document.getElementById('load-all-input').addEventListener('change', (e) => loadState(e, 'all'));
            
            document.getElementById('help-btn').addEventListener('click', () => showModal('help-modal'));
            document.getElementById('lang-select').addEventListener('change', (e) => {
                currentLang = e.target.value;
                appState.lang = currentLang;
                renderAll();
            });
            
            // Field area
            const fieldContainer = document.getElementById('field-container');
            fieldContainer.addEventListener('dblclick', (e) => {
                if (wasJustDragged) return;
                const fieldArea = document.getElementById('field-area');
                if(e.target === fieldContainer || e.target === fieldArea) showModal('field-settings-modal');
            });

            // Unified Drag & Drop
            document.addEventListener('mousedown', (e) => handleDragStart(e));
            window.addEventListener('mousemove', (e) => handleDragMove(e));
            window.addEventListener('mouseup', (e) => handleDragEnd(e));
            
            document.addEventListener('touchstart', (e) => handleDragStart(e.touches[0]), { passive: true });
            window.addEventListener('touchmove', (e) => {
                if (dragged.type) {
                    e.preventDefault();
                    handleDragMove(e.touches[0]);
                }
            }, { passive: false });
            window.addEventListener('touchend', (e) => handleDragEnd(e.changedTouches[0]));

            // Click and Double Click listeners
            document.body.addEventListener('click', handleClicks);
            document.body.addEventListener('dblclick', handleDoubleClicks);
            
            // Panel Drop for player list
            document.body.addEventListener('dragover', (e) => {
                const panelList = e.target.closest('.panel-tile-list');
                if (!dragged.type && panelList) {
                    e.preventDefault();
                    panelList.classList.add('drag-over');
                }
            });

            document.body.addEventListener('dragleave', (e) => {
                 const panelList = e.target.closest('.panel-tile-list');
                 if (panelList) {
                     panelList.classList.remove('drag-over');
                 }
            });
            
            document.body.addEventListener('drop', (e) => {
                const panelList = e.target.closest('.panel-tile-list');
                if (!dragged.type && panelList) {
                    e.preventDefault();
                    panelList.classList.remove('drag-over');
                    const teamId = panelList.closest('.team-panel').dataset.teamId;

                    const file = e.dataTransfer.files[0];
                    if (file && file.type === 'text/plain') {
                        const reader = new FileReader();
                        reader.onload = (re) => processPlayerList(re.target.result, teamId);
                        reader.readAsText(file);
                    } else {
                        const text = e.dataTransfer.getData('text/plain');
                        if (text) {
                            processPlayerList(text, teamId);
                        }
                    }
                }
            });

            setupModalEventListeners();
        }
        
        // --- Dragging Logic (Unified) ---
        function handleDragStart(e) {
            if (activeModal || dragged.type) return;
            const target = e.target;
            
            const fieldTile = target.closest('.tile-on-field');
            const panelTile = target.closest('.tile-on-panel');
            const ball = target.closest('.soccer-ball');

            if (!fieldTile && !panelTile && !ball) return;
            
            dragged.startX = e.clientX;
            dragged.startY = e.clientY;

            const sourceRect = (fieldTile || panelTile || ball).getBoundingClientRect();
            dragged.offsetX = e.clientX - sourceRect.left;
            dragged.offsetY = e.clientY - sourceRect.top;

            if (fieldTile) {
                dragged.type = 'tile-on-field';
                dragged.sourceElement = fieldTile;
                dragged.teamId = fieldTile.dataset.teamId;
                dragged.tileId = fieldTile.dataset.tileId;
                const tile = findTile(dragged.teamId, dragged.tileId);
                if (tile) {
                    dragged.initialX = tile.x;
                    dragged.initialY = tile.y;
                }
            } else if (ball) {
                dragged.type = 'ball';
                dragged.sourceElement = ball;
                dragged.initialX = appState.field.ball.x;
                dragged.initialY = appState.field.ball.y;
            } else if (panelTile) {
                dragged.type = 'panel-tile';
                dragged.sourceElement = panelTile;
                dragged.teamId = panelTile.dataset.teamId;
                dragged.tileId = panelTile.dataset.tileId;

                const clone = panelTile.cloneNode(true);
                clone.id = 'drag-clone';
                clone.style.width = `${sourceRect.width}px`;
                clone.style.height = `${sourceRect.height}px`;
                document.body.appendChild(clone);
                dragged.element = clone;
                
                updateDraggedElementPosition(e);
            }
        }

        function handleDragMove(e) {
            if (!dragged.type) return;

            if (!document.body.classList.contains('dragging')) {
                 const moved = Math.abs(e.clientX - dragged.startX) > 5 || Math.abs(e.clientY - dragged.startY) > 5;
                 if (moved) {
                    document.body.classList.add('dragging');
                    if (dragged.sourceElement) {
                        dragged.sourceElement.classList.add('dragging-source');
                    }
                 }
            }
            
            if (document.body.classList.contains('dragging')) {
                updateDraggedElementPosition(e);
                handleDragOver(e);
            }
        }
        
        function updateDraggedElementPosition(e) {
             let targetElement = dragged.type === 'panel-tile' ? dragged.element : dragged.sourceElement;
             if (!targetElement) return;

             if (dragged.type === 'panel-tile') {
                targetElement.style.left = `${e.clientX - dragged.offsetX}px`;
                targetElement.style.top = `${e.clientY - dragged.offsetY}px`;
             } else {
                const deltaX = e.clientX - dragged.startX;
                const deltaY = e.clientY - dragged.startY;
                targetElement.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
             }
        }
        
        function handleDragOver(e) {
            const placeholder = getOrCreatePlaceholder();
            if(dragged.element) dragged.element.style.display = 'none';
            const overElement = document.elementFromPoint(e.clientX, e.clientY);
            if(dragged.element) dragged.element.style.display = '';

            if (!overElement) return;

            const panel = overElement.closest('.team-panel');
            if (dragged.type === 'panel-tile' && panel) {
                const tileList = panel.querySelector('.panel-tile-list');
                const tiles = Array.from(tileList.querySelectorAll('.tile-on-panel:not(.dragging-source)'));
                
                const nextTile = tiles.find(tile => {
                    const rect = tile.getBoundingClientRect();
                    return e.clientY < rect.top + rect.height / 2;
                });
                
                if (nextTile) {
                    tileList.insertBefore(placeholder, nextTile);
                } else {
                    tileList.appendChild(placeholder);
                }
            } else {
                placeholder.remove();
            }
        }
        
        function getOrCreatePlaceholder() {
            let placeholder = document.querySelector('.drop-placeholder');
            if (!placeholder) {
                placeholder = document.createElement('div');
                placeholder.className = 'drop-placeholder';
            }
            return placeholder;
        }

        function handleDragEnd(e) {
            if (!dragged.type) {
                return;
            }

            const wasDragging = document.body.classList.contains('dragging');
            
            // Create a copy of the drag information before resetting state
            const dropInfo = {
                type: dragged.type,
                teamId: dragged.teamId,
                tileId: dragged.tileId,
                clientX: e ? e.clientX : dragged.startX,
                clientY: e ? e.clientY : dragged.startY,
                offsetX: dragged.offsetX,
                offsetY: dragged.offsetY,
            };

            // Reset state first to prevent race conditions with re-rendering
            resetDraggedState();

            if (wasDragging) {
                wasJustDragged = true;
                setTimeout(() => { wasJustDragged = false; }, 100);
                
                if (typeof dropInfo.clientX === 'number') {
                    handleDrop(dropInfo);
                } else {
                    renderAll(); 
                }
            }
        }

        function handleDrop(dropInfo) {
            const { clientX, clientY, type } = dropInfo;

            const fieldArea = document.getElementById('field-area');
            const teamPanel0 = document.getElementById('team-panel-0');
            const teamPanel1 = document.getElementById('team-panel-1');

            const fieldRect = fieldArea.getBoundingClientRect();
            const panel0Rect = teamPanel0.getBoundingClientRect();
            const panel1Rect = teamPanel1.getBoundingClientRect();
            
            let droppedOnValidTarget = false;

            if (clientX >= fieldRect.left && clientX <= fieldRect.right && clientY >= fieldRect.top && clientY <= fieldRect.bottom) {
                if (['panel-tile', 'ball', 'tile-on-field'].includes(type)) {
                    dropOnField(dropInfo);
                    droppedOnValidTarget = true;
                }
            } else if (clientX >= panel0Rect.left && clientX <= panel0Rect.right && clientY >= panel0Rect.top && clientY <= panel0Rect.bottom) {
                if (['panel-tile', 'tile-on-field'].includes(type)) {
                    dropOnPanel(teamPanel0, dropInfo);
                    droppedOnValidTarget = true;
                }
            } else if (clientX >= panel1Rect.left && clientX <= panel1Rect.right && clientY >= panel1Rect.top && clientY <= panel1Rect.bottom) {
                if (['panel-tile', 'tile-on-field'].includes(type)) {
                    dropOnPanel(teamPanel1, dropInfo);
                    droppedOnValidTarget = true;
                }
            }

            if (!droppedOnValidTarget) {
                 if (type === 'tile-on-field' || type === 'ball') {
                    // Snap back by re-rendering
                    renderAll();
                 } else if (type === 'panel-tile') {
                     // Tile from panel dropped outside, return it
                    const tile = findTile(dropInfo.teamId, dropInfo.tileId);
                    if (tile) {
                        tile.location = 'panel';
                    }
                    renderAll();
                 }
            }
        }
        
        function dropOnField(dropInfo) {
            const { clientX, clientY, type, teamId, tileId, offsetX, offsetY } = dropInfo;
            const fieldRect = document.getElementById('field-area').getBoundingClientRect();
            
            if (type === 'panel-tile' || type === 'tile-on-field') {
                const tile = findTile(teamId, tileId);
                if (!tile) return;
                const team = appState.teams[teamId];
                const tileSize = team.settings.tileSize || 60;
                
                const centerX = clientX - offsetX + tileSize / 2;
                const centerY = clientY - offsetY + tileSize / 2;

                let x = ((centerX - fieldRect.left) / fieldRect.width) * 100;
                let y = ((centerY - fieldRect.top) / fieldRect.height) * 100;
                
                tile.location = 'field';
                tile.x = Math.max(0, Math.min(100, x));
                tile.y = Math.max(0, Math.min(100, y));

            } else if (type === 'ball') {
                const centerX = clientX - offsetX + BALL_SIZE / 2;
                const centerY = clientY - offsetY + BALL_SIZE / 2;

                let x = ((centerX - fieldRect.left) / fieldRect.width) * 100;
                let y = ((centerY - fieldRect.top) / fieldRect.height) * 100;

                 appState.field.ball.x = Math.max(0, Math.min(100, x));
                 appState.field.ball.y = Math.max(0, Math.min(100, y));
            }
            renderAll();
        }
        
        function dropOnPanel(panel, dropInfo) {
            const { teamId, tileId } = dropInfo;
            const targetTeamId = panel.dataset.teamId;
            const tile = findTile(teamId, tileId);
            if (!tile) return;

            if (targetTeamId !== teamId) {
                const originalTeam = appState.teams[teamId];
                const tileIndex = originalTeam.tiles.findIndex(t => t.id === tileId);
                if (tileIndex > -1) originalTeam.tiles.splice(tileIndex, 1);
                
                tile.id = `${targetTeamId}-${Date.now()}`;
                appState.teams[targetTeamId].tiles.push(tile);
            }
            
            tile.location = 'panel';
            tile.x = null;
            tile.y = null;
            
            const placeholder = document.querySelector('.drop-placeholder');
            if (placeholder) {
                const panelTiles = appState.teams[targetTeamId].tiles.filter(t => t.location === 'panel').sort((a,b) => a.order - b.order);
                const draggedTileInArray = panelTiles.find(t => t.id === tile.id);
                const otherTiles = panelTiles.filter(t => t.id !== tile.id);
                
                const nextElementId = placeholder.nextElementSibling?.dataset.tileId;
                let newIndex;
                if(nextElementId) {
                    newIndex = otherTiles.findIndex(t => t.id === nextElementId);
                } else {
                    newIndex = otherTiles.length;
                }
                
                otherTiles.splice(newIndex, 0, draggedTileInArray);
                otherTiles.forEach((t, index) => t.order = index);
            }
            
            renderAll();
        }


        // --- Other event handlers ---
        function handleClicks(e) {
            if (wasJustDragged) return;

            const teamSettingsBtn = e.target.closest('.team-settings-btn');
            if (teamSettingsBtn) {
                showModal('team-settings-modal', { teamId: teamSettingsBtn.dataset.teamId });
                return;
            }
            const addPlayerBtn = e.target.closest('.add-player-btn');
            if(addPlayerBtn) {
                const teamId = parseInt(addPlayerBtn.dataset.teamId);
                const team = appState.teams[teamId];
                const newNumber = team.tiles.length > 0 ? Math.max(...team.tiles.map(t => parseInt(t.number) || 0)) + 1 : 1;
                const newOrder = team.tiles.length > 0 ? Math.max(...team.tiles.map(t => t.order)) + 1 : 0;
                const newId = `${teamId}-${Date.now()}`;
                team.tiles.push(createDefaultTile(newId, newNumber, newOrder));
                renderAll();
                return;
            }
            
            const deleteTileBtn = e.target.closest('.delete-tile-btn');
             if (deleteTileBtn) {
                const teamId = deleteTileBtn.dataset.teamId;
                const tileId = deleteTileBtn.dataset.tileId;
                const tile = findTile(teamId, tileId);
                if (tile) {
                    showConfirmModal(
                        `${t('confirm_delete_message')} (${tile.name})`,
                        () => {
                            const team = appState.teams[teamId];
                            team.tiles = team.tiles.filter(t => t.id !== tileId);
                            renderAll();
                        }
                    );
                }
                return;
            }

            const clearPlayersBtn = e.target.closest('.clear-players-btn');
            if (clearPlayersBtn) {
                const teamId = clearPlayersBtn.dataset.teamId;
                const team = appState.teams[teamId];
                if (team) {
                    showConfirmModal(
                        `${t('confirm_clear_all_players_message')} (${team.name})`,
                        () => {
                            team.tiles = [];
                            renderAll();
                        }
                    );
                }
                return;
            }

            const sortBtn = e.target.closest('.sort-team-btn');
            if (sortBtn) {
                const teamId = parseInt(sortBtn.dataset.teamId, 10);
                const team = appState.teams[teamId];
                const currentSort = team.sortState || 'custom';
                
                let nextSort;
                if (currentSort === 'custom') {
                    nextSort = 'position';
                } else if (currentSort === 'position') {
                    nextSort = 'number';
                } else {
                    nextSort = 'custom'; 
                }
                
                team.sortState = nextSort;
                sortTeam(teamId);
                renderAll();
                return;
            }
            
            const saveTeamBtn = e.target.closest('.save-team-btn');
            if (saveTeamBtn) {
                const teamId = parseInt(saveTeamBtn.dataset.teamId);
                saveState('team', teamId);
                return;
            }

            const loadTeamBtn = e.target.closest('.load-team-btn');
            if (loadTeamBtn) {
                const teamId = parseInt(loadTeamBtn.dataset.teamId);
                document.getElementById(`load-team-input-${teamId}`).click();
                return;
            }

            const markBtn = e.target.closest('.mark-btn');
            if (markBtn) {
                const { teamId, tileId } = activeModalData;
                const tile = findTile(teamId, tileId);
                const markType = markBtn.dataset.markType;
                if(tile && tile.marks.hasOwnProperty(markType)) {
                    if (['yellowCard', 'redCard', 'captain', 'substitution'].includes(markType)) {
                        tile.marks[markType] = tile.marks[markType] > 0 ? 0 : 1;
                    } else if (markType === 'goal') {
                        tile.marks.goal++;
                    } else if (markType === 'assist') {
                        tile.marks.assist++;
                    }
                }
                hideModals();
                renderAll();
            }
            if (e.target.id === 'clear-marks-btn') {
                const { teamId, tileId } = activeModalData;
                const tile = findTile(teamId, tileId);
                if (tile) {
                   Object.keys(tile.marks).forEach(key => tile.marks[key] = 0);
                }
                hideModals();
                renderAll();
            }
        }

        function sortTeam(teamId) {
            const team = appState.teams[teamId];
            const tilesToSort = [...team.tiles]; // Create a mutable copy
            const sortState = team.sortState;

            if (sortState === 'position') {
                const positionOrder = ['GK', 'DF', 'MF', 'FW', ''];
                tilesToSort.sort((a, b) => {
                    const posA = positionOrder.indexOf(a.position);
                    const posB = positionOrder.indexOf(b.position);
                    if (posA !== posB) return posA - posB;
                    
                    const numA = parseInt(a.number, 10) || 0;
                    const numB = parseInt(b.number, 10) || 0;
                    return numA - numB;
                });
            } else if (sortState === 'number') {
                tilesToSort.sort((a, b) => {
                    let numA = parseInt(a.number, 10);
                    let numB = parseInt(b.number, 10);

                    if (isNaN(numA)) numA = Infinity;
                    if (isNaN(numB)) numB = Infinity;

                    if (numA === 0) numA = Infinity;
                    if (numB === 0) numB = Infinity;
                    
                    return numA - numB;
                });
            } else { // 'custom'
                // Revert to original order before any sorting
                tilesToSort.sort((a, b) => {
                    const idA = parseInt(a.id.split('-')[1]);
                    const idB = parseInt(b.id.split('-')[1]);
                    return idA - idB;
                });
            }

            // Update the 'order' property for all tiles based on the new sort.
            tilesToSort.forEach((sortedTile, index) => {
                const originalTile = findTile(teamId, sortedTile.id);
                if (originalTile) originalTile.order = index;
            });
        }


        function handleDoubleClicks(e) {
            if (wasJustDragged) return;

            const panelTile = e.target.closest('.tile-on-panel');
            if (panelTile) {
                showModal('tile-settings-modal', { teamId: panelTile.dataset.teamId, tileId: panelTile.dataset.tileId });
                return;
            }

            const fieldTile = e.target.closest('.tile-on-field');
            if (fieldTile) {
                showModal('field-tile-edit-modal', { teamId: fieldTile.dataset.teamId, tileId: fieldTile.dataset.tileId });
                return;
            }
        }
        
        function processPlayerList(text, teamId) {
            const team = appState.teams[teamId];
            if (!team) return;
            const lines = text.split(/\r?\n/).filter(line => line.trim());
            if (lines.length === 0) return;
            let maxOrder = team.tiles.length > 0 ? Math.max(...team.tiles.map(t => t.order)) : -1;
            
            lines.forEach(line => {
                let processedLine = line.trim();
                let affiliation = '', 
                    position = '',
                    number = '';

                // 1. 所属を抽出
                const affiliationMatch = processedLine.match(/\(([^)]+)\)|（([^）]+)）/);
                if (affiliationMatch) {
                    affiliation = affiliationMatch[1] || affiliationMatch[2] || '';
                    processedLine = processedLine.replace(affiliationMatch[0], '').trim();
                }
                
                // 2. ポジションを抽出
                const positionMatch = processedLine.match(/\b(GK|DF|MF|FW)\b/);
                if (positionMatch) {
                    position = positionMatch[1];
                    processedLine = processedLine.replace(positionMatch[0], '').trim();
                }
                
                // 3. 背番号を抽出 (1-3桁)
                const numberMatch = processedLine.match(/\b(\d{1,3})\b/);
                if (numberMatch) {
                    number = numberMatch[1];
                    processedLine = processedLine.replace(new RegExp('\\b' + numberMatch[0] + '\\b'), '').trim();
                }
                
                // 4. 残りを名前に (連続する空白は一つにまとめる)
                const name = processedLine.replace(/\s{2,}/g, ' ').trim() || 'Player';
                
                maxOrder++;
                const newId = `${teamId}-${Date.now()}-${maxOrder}`;
                const newTile = createDefaultTile(newId, number, maxOrder);
                newTile.name = name;
                newTile.affiliation = affiliation;
                newTile.position = position;
                team.tiles.push(newTile);
            });
            renderAll();
        }

        function setupModalEventListeners() {
            document.getElementById('toggle-orientation-btn').addEventListener('click', () => {
                const oldOrientation = appState.field.orientation;
                appState.field.orientation = oldOrientation === 'horizontal' ? 'vertical' : 'horizontal';
                
                const ball = appState.field.ball;
                const oldBallX = ball.x;
                const oldBallY = ball.y;
                if (oldOrientation === 'horizontal') {
                    ball.x = 100 - oldBallY;
                    ball.y = oldBallX;
                } else {
                    ball.x = oldBallY;
                    ball.y = 100 - oldBallX;
                }

                appState.teams.forEach(team => {
                    team.tiles.forEach(tile => {
                        if (tile.location === 'field') {
                            const oldX = tile.x;
                            const oldY = tile.y;
                            if (oldOrientation === 'horizontal') {
                                tile.x = 100 - oldY;
                                tile.y = oldX;
                            } else {
                                tile.x = oldY;
                                tile.y = 100 - oldX;
                            }
                        }
                    });

                    const dir = team.settings.attackDirection;
                    if (appState.field.orientation === 'vertical') {
                        if (dir === 'left') team.settings.attackDirection = 'up';
                        if (dir === 'right') team.settings.attackDirection = 'down';
                    } else {
                        if (dir === 'up') team.settings.attackDirection = 'left';
                        if (dir === 'down') team.settings.attackDirection = 'right';
                    }
                });
                renderAll();
                hideModals();
            });
            document.getElementById('swap-sides-btn').addEventListener('click', () => {
                const ball = appState.field.ball;
                ball.x = 100 - ball.x;
                ball.y = 100 - ball.y;

                const swapMap = { left: 'right', right: 'left', up: 'down', down: 'up' };
                appState.teams.forEach(team => {
                    team.settings.attackDirection = swapMap[team.settings.attackDirection] || team.settings.attackDirection;
                    team.tiles.forEach(tile => {
                        if (tile.location === 'field') {
                            tile.x = 100 - tile.x;
                            tile.y = 100 - tile.y;
                        }
                    });
                });

                renderAll();
                hideModals();
            });
            
            const teamSettingsForm = document.getElementById('team-settings-modal');
            const colorInputs = ['border-color-input', 'bg-color-input', 'number-color-input', 'name-color-input', 'affiliation-color-input'];
            
            teamSettingsForm.addEventListener('input', (e) => {
                if (!activeModalData.teamId) return;
                // 色のリアルタイム反映を避ける
                if (colorInputs.includes(e.target.id)) return;

                const team = appState.teams[activeModalData.teamId];
                if(!team) return;
                const s = team.settings;
                switch(e.target.id) {
                    case 'team-name-input': team.name = e.target.value; break;
                    case 'tile-shape-select': s.shape = e.target.value; break;
                    case 'border-width-input': 
                        s.borderWidth = parseFloat(e.target.value); 
                        document.getElementById('border-width-value').textContent = `${s.borderWidth}px`;
                        break;
                    case 'number-size-input': 
                        s.numberSize = parseInt(e.target.value); 
                        document.getElementById('number-size-value').textContent = `${s.numberSize}px`;
                        break;
                    case 'show-name-checkbox': s.showName = e.target.checked; break;
                    case 'show-affiliation-checkbox': s.showAffiliation = e.target.checked; break;
                    case 'attack-direction-select': s.attackDirection = e.target.value; break;
                    case 'tile-size-input': 
                        s.tileSize = parseInt(e.target.value);
                        document.getElementById('tile-size-value').textContent = `${s.tileSize}px`;
                        break;
                    case 'bg-image-opacity-input': s.bgImageOpacity = parseFloat(e.target.value); break;
                    case 'name-size-input': 
                        s.nameSize = parseInt(e.target.value); 
                        document.getElementById('name-size-value').textContent = `${s.nameSize}px`;
                        break;
                    case 'affiliation-size-input': 
                        s.affiliationSize = parseInt(e.target.value); 
                        document.getElementById('affiliation-size-value').textContent = `${s.affiliationSize}px`;
                        break;
                }
                renderAll();
            });

            colorInputs.forEach(id => {
                document.getElementById(id).addEventListener('change', (e) => {
                    if (!activeModalData.teamId) return;
                    const team = appState.teams[activeModalData.teamId];
                    if (!team) return;
                    switch(id) {
                        case 'border-color-input': team.settings.borderColor = e.target.value; break;
                        case 'bg-color-input': team.settings.bgColor = e.target.value; break;
                        case 'number-color-input': team.settings.numberColor = e.target.value; break;
                        case 'name-color-input': team.settings.nameColor = e.target.value; break;
                        case 'affiliation-color-input': team.settings.affiliationColor = e.target.value; break;
                    }
                    renderAll();
                });
            });

            const tileSettingsForm = document.getElementById('tile-settings-modal');
            tileSettingsForm.addEventListener('input', (e) => {
                 if (!activeModalData.teamId || !activeModalData.tileId) return;
                 const tile = findTile(activeModalData.teamId, activeModalData.tileId);
                 if(!tile) return;
                 switch(e.target.id) {
                    case 'tile-name-input': tile.name = e.target.value; break;
                    case 'tile-number-input': tile.number = e.target.value; break;
                    case 'tile-position-select': tile.position = e.target.value; break;
                    case 'tile-affiliation-input': tile.affiliation = e.target.value; break;
                 }
                 renderAll();
            });
            
            const bgImageDropArea = document.getElementById('bg-image-drop-area');
            bgImageDropArea.addEventListener('dragover', (e) => { e.preventDefault(); bgImageDropArea.classList.add('drag-over'); });
            bgImageDropArea.addEventListener('dragleave', () => bgImageDropArea.classList.remove('drag-over'));
            bgImageDropArea.addEventListener('drop', (e) => {
                e.preventDefault();
                bgImageDropArea.classList.remove('drag-over');
                if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                    const file = e.dataTransfer.files[0];
                    if (file.type.startsWith('image/')) {
                        const reader = new FileReader();
                        reader.onload = (re) => {
                            const team = appState.teams[activeModalData.teamId];
                            team.settings.bgImage = re.target.result;
                            renderAll();
                        };
                        reader.readAsDataURL(file);
                    }
                }
            });
            document.getElementById('clear-bg-image-btn').addEventListener('click', () => {
                 const team = appState.teams[activeModalData.teamId];
                 team.settings.bgImage = null;
                 renderAll();
            });

            const nameListDropArea = document.getElementById('name-list-drop-area');
            nameListDropArea.addEventListener('dragover', (e) => { e.preventDefault(); nameListDropArea.classList.add('drag-over'); });
            nameListDropArea.addEventListener('dragleave', () => nameListDropArea.classList.remove('drag-over'));
            nameListDropArea.addEventListener('drop', (e) => {
                e.preventDefault();
                nameListDropArea.classList.remove('drag-over');
                const teamId = activeModalData.teamId;

                const file = e.dataTransfer.files[0];
                if (file && file.type === 'text/plain') {
                    const reader = new FileReader();
                    reader.onload = (re) => {
                        processPlayerList(re.target.result, teamId);
                        hideModals();
                    };
                    reader.readAsText(file);
                } else {
                    const text = e.dataTransfer.getData('text/plain');
                    if(text) {
                        processPlayerList(text, teamId);
                        hideModals();
                    }
                }
            });
            
            document.getElementById('change-ball-image-btn').addEventListener('click', () => {
                document.getElementById('ball-image-input').click();
            });
             document.getElementById('ball-image-input').addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        appState.field.ball.imageSrc = e.target.result;
                        renderAll();
                    };
                    reader.readAsDataURL(file);
                }
                event.target.value = null; // Reset input
            });
            document.getElementById('reset-ball-image-btn').addEventListener('click', () => {
                appState.field.ball.imageSrc = defaultAppState.field.ball.imageSrc;
                renderAll();
            });

            document.getElementById('change-grass-image-btn').addEventListener('click', () => document.getElementById('grass-image-input').click());
            document.getElementById('grass-image-input').addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => { appState.field.grassImage = e.target.result; renderAll(); };
                    reader.readAsDataURL(file);
                }
                event.target.value = null;
            });
            document.getElementById('reset-grass-image-btn').addEventListener('click', () => {
                appState.field.grassImage = defaultAppState.field.grassImage;
                renderAll();
            });

            document.getElementById('confirm-modal-ok-btn').addEventListener('click', () => {
                if (confirmCallback) confirmCallback();
                hideModals();
            });
            document.getElementById('confirm-modal-cancel-btn').addEventListener('click', hideModals);
            
            document.querySelectorAll('.load-team-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const teamId = e.currentTarget.dataset.teamId;
                    document.getElementById(`load-team-input-${teamId}`).click();
                });
            });

            document.querySelectorAll('input[type="file"][id^="load-team-input-"]').forEach(input => {
                input.addEventListener('change', (e) => {
                    const teamId = e.currentTarget.dataset.teamId;
                    loadState(e, 'team', teamId);
                });
            });
        }
        
        function loadTeamSettings() {
            const team = appState.teams[activeModalData.teamId];
            if(!team) return;
            const s = team.settings;
            document.getElementById('team-name-input').value = team.name;
            document.getElementById('tile-shape-select').value = s.shape;
            document.getElementById('border-color-input').value = s.borderColor;
            document.getElementById('border-width-input').value = s.borderWidth;
            document.getElementById('border-width-value').textContent = `${s.borderWidth}px`;
            document.getElementById('bg-color-input').value = s.bgColor;
            document.getElementById('number-color-input').value = s.numberColor;
            document.getElementById('number-size-input').value = s.numberSize;
            document.getElementById('number-size-value').textContent = `${s.numberSize}px`;
            document.getElementById('show-name-checkbox').checked = s.showName;
            document.getElementById('show-affiliation-checkbox').checked = s.showAffiliation;
            const tileSize = s.tileSize || 60;
            const tileSizeValue = document.getElementById('tile-size-value');
            document.getElementById('tile-size-input').value = tileSize;
            if(tileSizeValue) tileSizeValue.textContent = `${tileSize}px`;
            document.getElementById('bg-image-opacity-input').value = s.bgImageOpacity || 1;
            
            document.getElementById('name-color-input').value = s.nameColor;
            document.getElementById('name-size-input').value = s.nameSize;
            document.getElementById('name-size-value').textContent = `${s.nameSize}px`;
            document.getElementById('affiliation-color-input').value = s.affiliationColor;
            document.getElementById('affiliation-size-input').value = s.affiliationSize;
            document.getElementById('affiliation-size-value').textContent = `${s.affiliationSize}px`;

            const select = document.getElementById('attack-direction-select');
            const validOptions = { horizontal: ['left', 'right', 'none'], vertical: ['up', 'down', 'none'] }[appState.field.orientation];
            Array.from(select.options).forEach(opt => { opt.hidden = !validOptions.includes(opt.value); });
            if (!validOptions.includes(s.attackDirection)) { team.settings.attackDirection = validOptions[0]; }
            select.value = team.settings.attackDirection;
        }

        function loadTileSettings() {
             const tile = findTile(activeModalData.teamId, activeModalData.tileId);
             if(!tile) return;
             document.getElementById('tile-name-input').value = tile.name;
             document.getElementById('tile-number-input').value = tile.number;
             document.getElementById('tile-position-select').value = tile.position;
             document.getElementById('tile-affiliation-input').value = tile.affiliation;
        }

        function findTile(teamId, tileId) {
            return appState.teams[teamId]?.tiles.find(t => t.id === tileId);
        }

        // --- データ永続化 ---
        function saveState(type = 'all', teamId = null) {
            let dataToSave;
            let filename = `formation_${new Date().toISOString().slice(0, 10).replace(/-/g, '')}`;

            if (type === 'team' && teamId !== null) {
                const teamData = appState.teams[teamId];
                // フィールド上のタイル情報を除外して保存
                const teamToSave = JSON.parse(JSON.stringify(teamData));
                teamToSave.tiles.forEach(t => {
                    t.location = 'panel';
                    t.x = null;
                    t.y = null;
                });
                dataToSave = teamToSave;
                filename = `${teamData.name || 'team'}_${new Date().toISOString().slice(0, 10).replace(/-/g, '')}.json`;
            } else {
                dataToSave = appState;
                filename += '_all.json';
            }

            const dataStr = JSON.stringify(dataToSave, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function loadState(event, type = 'all', teamId = null) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const newState = JSON.parse(e.target.result);
                        if (type === 'all' && newState.teams && newState.field) {
                            appState = newState;
                             appState.teams.forEach(team => {
                                if (!team.sortState) team.sortState = 'custom';
                                if (team.settings.nameColor === undefined) {
                                    Object.assign(team.settings, defaultAppState.teams[0].settings);
                                }
                            });
                        } else if (type === 'team' && teamId !== null && newState.name && newState.tiles) {
                            // Clear existing players on field for the loading team
                            appState.teams[teamId].tiles.forEach(tile => {
                                tile.location = 'panel';
                            });
                            
                            // Load new team data
                            appState.teams[teamId] = newState;
                            if (!appState.teams[teamId].sortState) {
                                appState.teams[teamId].sortState = 'custom';
                            }

                        } else {
                             alert('Invalid file format.');
                             return;
                        }

                        currentLang = appState.lang || 'ja';
                        document.getElementById('lang-select').value = currentLang;
                        renderAll();

                    } catch (err) {
                        alert('Error reading file: ' + err.message);
                    } finally {
                        event.target.value = null;
                    }
                };
                reader.readAsText(file);
            }
        }

        // --- 初期化処理 ---
        initializeState();
        renderAll();
        setupEventListeners();
        
        new ResizeObserver(renderAll).observe(document.getElementById('field-container'));
    });
    </script>
</body>
</html>
